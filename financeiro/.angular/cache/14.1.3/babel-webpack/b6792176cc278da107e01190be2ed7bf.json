{"ast":null,"code":"import isSubset from '../../utils/isSubset';\nimport logger from \"../../utils/logger\";\nimport selectionLevel from '../../api-utils/selectionLevel';\nimport success from '../../api-utils/success';\nimport error from '../../api-utils/error';\nimport showUserErrors from '../../api-utils/showUserErrors';\nexport default function deleteIt() {\n  return new Promise((resolve, reject) => {\n    // delete database\n    this.deleteDatabase = () => {\n      let dbName = this.dbName;\n      indexedDB.deleteDatabase(dbName);\n      resolve(success.call(this, `Database \"${dbName}\" deleted.`, {\n        database: dbName\n      }));\n    }; // delete collection\n\n\n    this.deleteCollection = () => {\n      let dbName = this.dbName;\n      let collectionName = this.collectionName; // we can only delete one collection at a time, which is why we need a queue\n\n      this.addToDeleteCollectionQueue = collectionName => {\n        this.deleteCollectionQueue.queue.push(collectionName);\n        this.runDeleteCollectionQueue();\n      };\n\n      this.runDeleteCollectionQueue = () => {\n        if (this.deleteCollectionQueue.running == false) {\n          this.deleteCollectionQueue.running = true;\n          this.deleteNextCollectionFromQueue();\n        }\n      };\n\n      this.deleteNextCollectionFromQueue = () => {\n        if (this.deleteCollectionQueue.queue.length) {\n          let collectionToDelete = this.deleteCollectionQueue.queue[0];\n          this.deleteCollectionQueue.queue.shift();\n          this.lf[collectionToDelete].dropInstance({\n            name: dbName,\n            storeName: collectionToDelete\n          }).then(() => {\n            this.deleteNextCollectionFromQueue();\n            resolve(success.call(this, `Collection \"${collectionToDelete}\" deleted.`, {\n              collection: collectionToDelete\n            }));\n          }).catch(error => {\n            reject(error.call(this, `Collection \"${collectionToDelete}\" could not be deleted.`));\n          });\n        } else {\n          this.deleteCollectionQueue.running = false;\n        }\n      };\n\n      this.addToDeleteCollectionQueue(collectionName);\n    }; // delete document\n\n\n    this.deleteDocument = () => {\n      let collectionName = this.collectionName;\n      let docSelectionCriteria = this.docSelectionCriteria; // delete document by criteria\n\n      this.deleteDocumentByCriteria = () => {\n        let keysForDeletion = [];\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            keysForDeletion.push(key);\n          }\n        }).then(() => {\n          if (!keysForDeletion.length) {\n            reject(error.call(this, `No Documents found in \"${collectionName}\" Collection with criteria ${JSON.stringify(docSelectionCriteria)}. No documents deleted.`));\n          }\n\n          if (keysForDeletion.length > 1) {\n            logger.warn.call(this, `Multiple documents (${keysForDeletion.length}) with ${JSON.stringify(docSelectionCriteria)} found.`);\n          }\n        }).then(() => {\n          keysForDeletion.forEach((key, index) => {\n            this.lf[collectionName].removeItem(key).then(() => {\n              if (index === keysForDeletion.length - 1) {\n                resolve(success.call(this, `${keysForDeletion.length} Document${keysForDeletion.length > 1 ? 's' : ''} with ${JSON.stringify(docSelectionCriteria)} deleted.`, {\n                  keys: keysForDeletion\n                }));\n              }\n            }).catch(err => {\n              reject(error.call(this, `Could not delete ${keysForDeletion.length} Documents in ${collectionName} Collection.`));\n            });\n          });\n        });\n      }; // delete document by key\n\n\n      this.deleteDocumentByKey = () => {\n        this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n          if (value) {\n            this.lf[collectionName].removeItem(docSelectionCriteria).then(() => {\n              resolve(success.call(this, `Document with key ${JSON.stringify(docSelectionCriteria)} deleted.`, {\n                key: docSelectionCriteria\n              }));\n            }).catch(function (err) {\n              reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n            });\n          } else {\n            reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n          }\n        });\n      };\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.deleteDocumentByCriteria();\n      } else {\n        return this.deleteDocumentByKey();\n      }\n    };\n\n    if (!this.userErrors.length) {\n      let currentSelectionLevel = selectionLevel.call(this);\n\n      if (currentSelectionLevel == 'db') {\n        return this.deleteDatabase();\n      } else if (currentSelectionLevel == 'collection') {\n        return this.deleteCollection();\n      } else if (currentSelectionLevel == 'doc') {\n        return this.deleteDocument();\n      }\n    } else {\n      showUserErrors.call(this);\n    }\n  });\n}","map":{"version":3,"names":["isSubset","logger","selectionLevel","success","error","showUserErrors","deleteIt","Promise","resolve","reject","deleteDatabase","dbName","indexedDB","call","database","deleteCollection","collectionName","addToDeleteCollectionQueue","deleteCollectionQueue","queue","push","runDeleteCollectionQueue","running","deleteNextCollectionFromQueue","length","collectionToDelete","shift","lf","dropInstance","name","storeName","then","collection","catch","deleteDocument","docSelectionCriteria","deleteDocumentByCriteria","keysForDeletion","iterate","value","key","JSON","stringify","warn","forEach","index","removeItem","keys","err","deleteDocumentByKey","getItem","userErrors","currentSelectionLevel"],"sources":["D:/wender/projetos/cop-financeiro/financeiro/node_modules/localbase/localbase/api/actions/delete.js"],"sourcesContent":["import isSubset from '../../utils/isSubset'\nimport logger from \"../../utils/logger\"\nimport selectionLevel from '../../api-utils/selectionLevel'\nimport success from '../../api-utils/success'\nimport error from '../../api-utils/error'\nimport showUserErrors from '../../api-utils/showUserErrors'\n\nexport default function deleteIt() {\n\n  return new Promise((resolve, reject) => {\n\n    // delete database\n    this.deleteDatabase = () => {\n      let dbName = this.dbName\n\n      indexedDB.deleteDatabase(dbName)\n      resolve(\n        success.call(\n          this,\n          `Database \"${ dbName }\" deleted.`,\n          { database: dbName }\n        )\n      )\n    }\n\n    // delete collection\n    this.deleteCollection = () => {\n      let dbName = this.dbName\n      let collectionName = this.collectionName\n\n      // we can only delete one collection at a time, which is why we need a queue\n\n      this.addToDeleteCollectionQueue = (collectionName) => {\n        this.deleteCollectionQueue.queue.push(collectionName)\n        this.runDeleteCollectionQueue()\n      }\n\n      this.runDeleteCollectionQueue = () => {\n        if (this.deleteCollectionQueue.running == false) {\n          this.deleteCollectionQueue.running = true\n          this.deleteNextCollectionFromQueue()\n        }\n      }\n\n      this.deleteNextCollectionFromQueue = () => {\n        if (this.deleteCollectionQueue.queue.length) {\n          let collectionToDelete = this.deleteCollectionQueue.queue[0]\n          this.deleteCollectionQueue.queue.shift()\n\n          this.lf[collectionToDelete].dropInstance({\n            name        : dbName,\n            storeName   : collectionToDelete\n          }).then(() => {\n            this.deleteNextCollectionFromQueue()\n            resolve(\n              success.call(\n                this,\n                `Collection \"${ collectionToDelete }\" deleted.`,\n                { collection: collectionToDelete }\n              )\n            )\n          }).catch(error => {\n            reject(\n              error.call(\n                this,\n                `Collection \"${ collectionToDelete }\" could not be deleted.`\n              )\n            )\n          })\n        }\n        else {\n          this.deleteCollectionQueue.running = false\n        }\n      }\n\n      this.addToDeleteCollectionQueue(collectionName)\n    }\n\n    // delete document\n    this.deleteDocument = () => {\n\n      let collectionName = this.collectionName\n      let docSelectionCriteria = this.docSelectionCriteria\n\n      // delete document by criteria\n      this.deleteDocumentByCriteria = () => {\n        let keysForDeletion = []\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            keysForDeletion.push(key)\n          }\n        }).then(() => {\n          if (!keysForDeletion.length) {\n            reject(\n              error.call(\n                this,\n                `No Documents found in \"${ collectionName }\" Collection with criteria ${ JSON.stringify(docSelectionCriteria) }. No documents deleted.`\n              )\n            )\n          }\n          if (keysForDeletion.length > 1) {\n            logger.warn.call(this, `Multiple documents (${ keysForDeletion.length }) with ${ JSON.stringify(docSelectionCriteria) } found.`)\n          }\n        }).then(() => {\n          keysForDeletion.forEach((key, index) => {\n            this.lf[collectionName].removeItem(key).then(() => {\n              if (index === (keysForDeletion.length - 1)) {\n                resolve(\n                  success.call(\n                    this,\n                    `${ keysForDeletion.length } Document${ keysForDeletion.length > 1 ? 's' : '' } with ${ JSON.stringify(docSelectionCriteria) } deleted.`,\n                    { keys: keysForDeletion }\n                  )\n                )\n              }\n            }).catch(err => {\n              reject(\n                error.call(\n                  this,\n                  `Could not delete ${ keysForDeletion.length } Documents in ${ collectionName } Collection.`\n                )\n              )\n            })\n          })\n        })\n      }\n\n      // delete document by key\n      this.deleteDocumentByKey = () => {\n        this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n          if (value) {\n            this.lf[collectionName].removeItem(docSelectionCriteria).then(() => {\n              resolve(\n                success.call(\n                  this,\n                  `Document with key ${ JSON.stringify(docSelectionCriteria) } deleted.`,\n                  { key: docSelectionCriteria }\n                )\n              )\n            }).catch(function(err) {\n              reject(\n                error.call(\n                  this,\n                  `No Document found in \"${ collectionName }\" Collection with key ${ JSON.stringify(docSelectionCriteria) }. No document was deleted.`\n                )\n              )\n            });\n          }\n          else {\n            reject(\n              error.call(\n                this,\n                `No Document found in \"${ collectionName }\" Collection with key ${ JSON.stringify(docSelectionCriteria) }. No document was deleted.`\n              )\n            )\n          }\n        });\n\n      }\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.deleteDocumentByCriteria()\n      }\n      else {\n        return this.deleteDocumentByKey()\n      }\n    }\n    \n    if (!this.userErrors.length) {\n      let currentSelectionLevel = selectionLevel.call(this)\n  \n      if (currentSelectionLevel == 'db') {\n        return this.deleteDatabase()\n      }\n      else if (currentSelectionLevel == 'collection') {\n        return this.deleteCollection()\n      }\n      else if (currentSelectionLevel == 'doc') {\n        return this.deleteDocument()\n      }\n    }\n    else {\n      showUserErrors.call(this)\n    }\n\n  })\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}