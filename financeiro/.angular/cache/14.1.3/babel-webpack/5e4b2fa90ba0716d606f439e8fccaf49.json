{"ast":null,"code":"import logger from '../../utils/logger';\nimport isSubset from '../../utils/isSubset';\nimport updateObject from '../../utils/updateObject';\nimport success from '../../api-utils/success';\nimport error from '../../api-utils/error';\nimport showUserErrors from '../../api-utils/showUserErrors';\nexport default function update(docUpdates) {\n  let collectionName = this.collectionName;\n  let docSelectionCriteria = this.docSelectionCriteria;\n  return new Promise((resolve, reject) => {\n    // update document by criteria\n    this.updateDocumentByCriteria = () => {\n      let docsToUpdate = [];\n      this.lf[collectionName].iterate((value, key) => {\n        if (isSubset(value, docSelectionCriteria)) {\n          let newDocument = updateObject(value, docUpdates);\n          docsToUpdate.push({\n            key,\n            newDocument\n          });\n        }\n      }).then(() => {\n        if (!docsToUpdate.length) {\n          reject(error.call(this, `No Documents found in ${collectionName} Collection with criteria ${JSON.stringify(docSelectionCriteria)}.`));\n        }\n\n        if (docsToUpdate.length > 1) {\n          logger.warn.call(this, `Multiple documents (${docsToUpdate.length}) with ${JSON.stringify(docSelectionCriteria)} found for updating.`);\n        }\n      }).then(() => {\n        docsToUpdate.forEach((docToUpdate, index) => {\n          this.lf[collectionName].setItem(docToUpdate.key, docToUpdate.newDocument).then(value => {\n            if (index === docsToUpdate.length - 1) {\n              resolve(success.call(this, `${docsToUpdate.length} Document${docsToUpdate.length > 1 ? 's' : ''} in \"${collectionName}\" collection with ${JSON.stringify(docSelectionCriteria)} updated.`, docUpdates));\n            }\n          }).catch(err => {\n            reject(error.call(this, `Could not update ${docsToUpdate.length} Documents in ${collectionName} Collection.`));\n          });\n        });\n      });\n    }; // update document by key\n\n\n    this.updateDocumentByKey = () => {\n      let newDocument = {};\n      this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n        newDocument = updateObject(value, docUpdates);\n        this.lf[collectionName].setItem(docSelectionCriteria, newDocument);\n        resolve(success.call(this, `Document in \"${collectionName}\" collection with key ${JSON.stringify(docSelectionCriteria)} updated.`, newDocument));\n      }).catch(err => {\n        reject(error.call(this, `No Document found in \"${collectionName}\" collection with key ${JSON.stringify(docSelectionCriteria)}`));\n      });\n    }; // check for user errors\n\n\n    if (!docUpdates) {\n      this.userErrors.push('No update object provided to update() method. Use an object e.g. { name: \"William\" }');\n    } else if (!(typeof docUpdates == 'object' && docUpdates instanceof Array == false)) {\n      this.userErrors.push('Data passed to .update() must be an object. Not an array, string, number or boolean.');\n    }\n\n    if (!this.userErrors.length) {\n      if (typeof docSelectionCriteria == 'object') {\n        this.updateDocumentByCriteria();\n      } else {\n        this.updateDocumentByKey();\n      }\n    } else {\n      showUserErrors.call(this);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}