{"ast":null,"code":"import isSubset from '../../utils/isSubset';\nimport logger from \"../../utils/logger\";\nimport selectionLevel from '../../api-utils/selectionLevel';\nimport success from '../../api-utils/success';\nimport error from '../../api-utils/error';\nimport showUserErrors from '../../api-utils/showUserErrors';\nexport default function deleteIt() {\n  return new Promise((resolve, reject) => {\n    // delete database\n    this.deleteDatabase = () => {\n      let dbName = this.dbName;\n      indexedDB.deleteDatabase(dbName);\n      resolve(success.call(this, `Database \"${dbName}\" deleted.`, {\n        database: dbName\n      }));\n    }; // delete collection\n\n\n    this.deleteCollection = () => {\n      let dbName = this.dbName;\n      let collectionName = this.collectionName; // we can only delete one collection at a time, which is why we need a queue\n\n      this.addToDeleteCollectionQueue = collectionName => {\n        this.deleteCollectionQueue.queue.push(collectionName);\n        this.runDeleteCollectionQueue();\n      };\n\n      this.runDeleteCollectionQueue = () => {\n        if (this.deleteCollectionQueue.running == false) {\n          this.deleteCollectionQueue.running = true;\n          this.deleteNextCollectionFromQueue();\n        }\n      };\n\n      this.deleteNextCollectionFromQueue = () => {\n        if (this.deleteCollectionQueue.queue.length) {\n          let collectionToDelete = this.deleteCollectionQueue.queue[0];\n          this.deleteCollectionQueue.queue.shift();\n          this.lf[collectionToDelete].dropInstance({\n            name: dbName,\n            storeName: collectionToDelete\n          }).then(() => {\n            this.deleteNextCollectionFromQueue();\n            resolve(success.call(this, `Collection \"${collectionToDelete}\" deleted.`, {\n              collection: collectionToDelete\n            }));\n          }).catch(error => {\n            reject(error.call(this, `Collection \"${collectionToDelete}\" could not be deleted.`));\n          });\n        } else {\n          this.deleteCollectionQueue.running = false;\n        }\n      };\n\n      this.addToDeleteCollectionQueue(collectionName);\n    }; // delete document\n\n\n    this.deleteDocument = () => {\n      let collectionName = this.collectionName;\n      let docSelectionCriteria = this.docSelectionCriteria; // delete document by criteria\n\n      this.deleteDocumentByCriteria = () => {\n        let keysForDeletion = [];\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            keysForDeletion.push(key);\n          }\n        }).then(() => {\n          if (!keysForDeletion.length) {\n            reject(error.call(this, `No Documents found in \"${collectionName}\" Collection with criteria ${JSON.stringify(docSelectionCriteria)}. No documents deleted.`));\n          }\n\n          if (keysForDeletion.length > 1) {\n            logger.warn.call(this, `Multiple documents (${keysForDeletion.length}) with ${JSON.stringify(docSelectionCriteria)} found.`);\n          }\n        }).then(() => {\n          keysForDeletion.forEach((key, index) => {\n            this.lf[collectionName].removeItem(key).then(() => {\n              if (index === keysForDeletion.length - 1) {\n                resolve(success.call(this, `${keysForDeletion.length} Document${keysForDeletion.length > 1 ? 's' : ''} with ${JSON.stringify(docSelectionCriteria)} deleted.`, {\n                  keys: keysForDeletion\n                }));\n              }\n            }).catch(err => {\n              reject(error.call(this, `Could not delete ${keysForDeletion.length} Documents in ${collectionName} Collection.`));\n            });\n          });\n        });\n      }; // delete document by key\n\n\n      this.deleteDocumentByKey = () => {\n        this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n          if (value) {\n            this.lf[collectionName].removeItem(docSelectionCriteria).then(() => {\n              resolve(success.call(this, `Document with key ${JSON.stringify(docSelectionCriteria)} deleted.`, {\n                key: docSelectionCriteria\n              }));\n            }).catch(function (err) {\n              reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n            });\n          } else {\n            reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n          }\n        });\n      };\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.deleteDocumentByCriteria();\n      } else {\n        return this.deleteDocumentByKey();\n      }\n    };\n\n    if (!this.userErrors.length) {\n      let currentSelectionLevel = selectionLevel.call(this);\n\n      if (currentSelectionLevel == 'db') {\n        return this.deleteDatabase();\n      } else if (currentSelectionLevel == 'collection') {\n        return this.deleteCollection();\n      } else if (currentSelectionLevel == 'doc') {\n        return this.deleteDocument();\n      }\n    } else {\n      showUserErrors.call(this);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}